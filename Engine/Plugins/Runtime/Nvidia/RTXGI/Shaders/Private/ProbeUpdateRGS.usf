/*
* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
*
* NVIDIA CORPORATION and its licensors retain all intellectual property
* and proprietary rights in and to this software, related documentation
* and any modifications thereto.  Any use, reproduction, disclosure or
* distribution of this software and related documentation without an express
* license agreement from NVIDIA CORPORATION is strictly prohibited.
*/

#include "/Engine/Private/HairStrands/HairStrandsVoxelPageCommonStruct.ush"
#include "/Engine/Private/Common.ush"

struct DDGIVolumeDescGPU
{
    float3 origin;
    int numRaysPerProbe;
    float4 rotation;
    float3 probeGridSpacing;
    float probeMaxRayDistance;
    int3 probeGridCounts;
    float4x4 probeRayRotationTransform;
    float normalBias;
    float viewBias;
    float probeNumIrradianceTexels;
    float probeNumDistanceTexels;
    float probeIrradianceEncodingGamma;
    int3 probeScrollOffsets;
};

// RTXGI SDK
#include "/Plugin/RTXGI/Private/SDK/ddgi/Irradiance.ush"

// needed by DeferredLightingCommon included indirectly
#define SUPPORT_CONTACT_SHADOWS 0

// from RayTracingPrimaryRays.usf - see that .cpp for how to pass all these params properly
#define LTCMatTexture               RaytracingLightsDataPacked.LTCMatTexture
#define LTCMatSampler               RaytracingLightsDataPacked.LTCMatSampler
#define LTCAmpTexture               RaytracingLightsDataPacked.LTCAmpTexture
#define LTCAmpSampler               RaytracingLightsDataPacked.LTCAmpSampler
#define PreIntegratedGF             ReflectionStruct.PreIntegratedGF
#define PreIntegratedGFSampler      ReflectionStruct.PreIntegratedGFSampler

#include "/Engine/Private/DeferredLightingCommon.ush"
#include "/Engine/Private/DeferredShadingCommon.ush"
#include "/Engine/Private/PathTracing/Utilities/PathTracingRandomSequence.ush"
#include "/Engine/Private/SceneTextureParameters.ush"
#include "/Engine/Private/RayTracing/RayTracingCommon.ush"
#include "/Engine/Private/RayTracing/RayTracingDeferredShadingCommon.ush"
#include "/Engine/Private/RayTracing/RayTracingHitGroupCommon.ush"
#include "/Engine/Private/RayTracing/RayTracingDirectionalLight.ush"
#include "/Engine/Private/RayTracing/RayTracingRectLight.ush"
#include "/Engine/Private/RayTracing/RayTracingSphereLight.ush"
#include "/Engine/Private/RayTracing/RayTracingSpotLight.ush"
#include "/Engine/Private/RayTracing/RayTracingPointLight.ush"
#include "/Engine/Private/RayTracing/RayTracingLightingCommon.ush"
#include "/Engine/Private/ReflectionEnvironmentShared.ush"
#include "/Engine/Private/Montecarlo.ush"
#include "/Engine/Private/HeightFogCommon.ush"
#include "/Engine/Private/SobolRandom.ush"

// START RGS PARAMS
RaytracingAccelerationStructure TLAS;

RWTexture2D<float4> RadianceOutput;
RWTexture2D<float4> DebugOutput;

uint   FrameRandomSeed;

Texture2D<float4>   DDGIVolume_ProbeIrradiance;
Texture2D<float4>   DDGIVolume_ProbeDistance;
RWTexture2D<float4> DDGIVolume_ProbeOffsets;
Texture2D<uint>     DDGIVolume_ProbeStates;
float3              DDGIVolume_Origin;
float4              DDGIVolume_Rotation;
float3              DDGIVolume_ProbeGridSpacing;
float               DDGIVolume_ProbeMaxRayDistance;
int3                DDGIVolume_ProbeGridCounts;
float4x4            DDGIVolume_ProbeRayRotationTransform;
int                 DDGIVolume_NumRaysPerProbe;
float3              DDGIVolume_Radius;
int                 DDGIVolume_ProbeNumIrradianceTexels;
int                 DDGIVolume_ProbeNumDistanceTexels;
float               DDGIVolume_ProbeIrradianceEncodingGamma;
float               DDGIVolume_NormalBias;
float               DDGIVolume_ViewBias;
SamplerState        DDGIVolume_LinearClampSampler;
int3                DDGIVolume_ProbeScrollOffsets;
float               DDGIVolume_IrradianceScalar;
int                 DDGIVolume_ProbeIndexStart;
int                 DDGIVolume_ProbeIndexCount;
float               DDGIVolume_EmissiveMultiplier;

float3              Sky_Color;
TextureCube<float4> Sky_Texture;
SamplerState        Sky_TextureSampler;

// END RGS PARAMS

float3 GetEnvironmentalRadiance(in float3 direction)
{
    return Sky_Color * TextureCubeSampleLevel(Sky_Texture, Sky_TextureSampler, direction, 0).rgb;
}

void WriteRadianceOutput(uint2 DispatchIndex, float4 value)
{
#if !RTXGI_DDGI_DEBUG_FORMAT_RADIANCE
    static const float c_threshold = 1.f / 255.f;
    if (RTXGIMaxComponent(value.rgb) <= c_threshold) value.rgb = float3(0.f, 0.f, 0.f);
#endif

    // Radiance / irradiance is multipled by this when stored, but divided by this when recalled.
    // This feature is to avoid clipping when using the 10 bit texture format.
    value.rgb *= DDGIVolume_IrradianceScalar;

#if RTXGI_DDGI_DEBUG_FORMAT_RADIANCE
    // Use R32G32B32A32_FLOAT format. Store color components and hit distance as 32-bit float values.
    RadianceOutput[DispatchIndex.xy] = value;
#else
    // Use R32G32_FLOAT format (don't use R32G32_UINT since hit distance needs to be negative sometimes).
    // Pack color as R10G10B10 in R32 and store hit distance in G32.
    RadianceOutput[DispatchIndex.xy] = float4(asfloat(RTXGIFloat3ToUint(clamp(value.rgb, 0.0f, 1.0f))), value.w, 0.f, 0.f);
#endif

#if DDGIVolumeUpdateDebug != 0
    DebugOutput[DispatchIndex.xy] = value;
#endif
}

RAY_TRACING_ENTRY_RAYGEN(ProbeUpdateRGS)
{
    DDGIVolumeDescGPU DDGIVolume;
    DDGIVolume.origin = DDGIVolume_Origin;
    DDGIVolume.numRaysPerProbe = DDGIVolume_NumRaysPerProbe;
    DDGIVolume.rotation = DDGIVolume_Rotation;
    DDGIVolume.probeGridSpacing = DDGIVolume_ProbeGridSpacing;
    DDGIVolume.probeMaxRayDistance = DDGIVolume_ProbeMaxRayDistance;
    DDGIVolume.probeGridCounts = DDGIVolume_ProbeGridCounts;
    DDGIVolume.probeRayRotationTransform = DDGIVolume_ProbeRayRotationTransform;
    DDGIVolume.normalBias = DDGIVolume_NormalBias;
    DDGIVolume.viewBias = DDGIVolume_ViewBias;
    DDGIVolume.probeNumIrradianceTexels = DDGIVolume_ProbeNumIrradianceTexels;
    DDGIVolume.probeNumDistanceTexels = DDGIVolume_ProbeNumDistanceTexels;
    DDGIVolume.probeIrradianceEncodingGamma = DDGIVolume_ProbeIrradianceEncodingGamma;
    DDGIVolume.probeScrollOffsets = DDGIVolume_ProbeScrollOffsets;

    // Adapted from ProbeTraceRGS.hlsl in the test harness aiming for minimal changes to help future merges.

    float4 result = 0.f;

    uint2 DispatchIndex = DispatchRaysIndex().xy;
    int rayIndex = DispatchIndex.x;                    // index of ray within a probe
    int probeIndex = DispatchIndex.y;                  // index of current probe

    // Handle round robin updating.
    // If this probe is outside of the window for updating, bail out.
    {
        int numProbes = DDGIVolume_ProbeGridCounts.x * DDGIVolume_ProbeGridCounts.y * DDGIVolume_ProbeGridCounts.z;
        int probeRRIndex = (probeIndex < DDGIVolume_ProbeIndexStart) ? probeIndex + numProbes : probeIndex;
        if (probeRRIndex >= DDGIVolume_ProbeIndexStart + DDGIVolume_ProbeIndexCount)
            return;
    }

#if RTXGI_DDGI_PROBE_STATE_CLASSIFIER
#if RTXGI_DDGI_PROBE_SCROLL
    int storageProbeIndex = DDGIGetProbeIndexOffset(probeIndex, DDGIVolume.probeGridCounts, DDGIVolume.probeScrollOffsets);
#else
    int storageProbeIndex = probeIndex;
#endif
    int2 texelPosition = DDGIGetProbeTexelPosition(storageProbeIndex, DDGIVolume.probeGridCounts);
    int  probeState = DDGIVolume_ProbeStates.Load(int3(texelPosition, 0));
    if (probeState == PROBE_STATE_INACTIVE && rayIndex >= RTXGI_DDGI_NUM_FIXED_RAYS)
    {
       // if the probe is inactive, do not shoot rays, unless it is one of the fixed rays that could potentially reactivate the probe
       return;
    }
#endif

#if RTXGI_DDGI_PROBE_RELOCATION
    #if RTXGI_DDGI_PROBE_SCROLL
    float3 probeWorldPosition = DDGIGetProbeWorldPositionWithOffset(probeIndex, DDGIVolume.origin, DDGIVolume.rotation, DDGIVolume.probeGridCounts, DDGIVolume.probeGridSpacing, DDGIVolume.probeScrollOffsets, DDGIVolume_ProbeOffsets);
    #else
    float3 probeWorldPosition = DDGIGetProbeWorldPositionWithOffset(probeIndex, DDGIVolume.origin, DDGIVolume.rotation, DDGIVolume.probeGridCounts, DDGIVolume.probeGridSpacing, DDGIVolume_ProbeOffsets);
    #endif
#else
    float3 probeWorldPosition = DDGIGetProbeWorldPosition(probeIndex, DDGIVolume.origin, DDGIVolume.rotation, DDGIVolume.probeGridCounts, DDGIVolume.probeGridSpacing);
#endif

    float3 probeRayDirection = DDGIGetProbeRayDirection(rayIndex, DDGIVolume.numRaysPerProbe, DDGIVolume.probeRayRotationTransform);

    // Setup the probe ray
    RayDesc Ray;
    Ray.Origin = probeWorldPosition;
    Ray.Direction = probeRayDirection;
    Ray.TMin = 0.f;
    Ray.TMax = DDGIVolume.probeMaxRayDistance;

    const int ReflectedShadowsType = 1; // = hard shadows.  make configurable?
    const uint RefractionRayFlags = 0;
    const uint RefractionInstanceInclusionMask = RAY_TRACING_MASK_ALL;

    #if DDGI_SKYLIGHT
    const bool bRefractionEnableSkyLightContribution = true;
    #else
    const bool bRefractionEnableSkyLightContribution = false;
    #endif

    const bool bRefractionRayTraceSkyLightContribution = false;
    const bool bRefractionDecoupleSampleGeneration = true;
    const bool ShouldDoDirectLighting = true;
    const bool ShouldDoEmissiveAndIndirectLighting = true;
    float3 PathVertexRadiance = float3(0, 0, 0);
    FRayCone RayCone = (FRayCone)0;
    float MaxNormalBias = 0.01f;

    // Trace
    uint linear_rand = DispatchIndex.x + DispatchIndex.y * 9973;
    RandomSequence RandSequence;
    RandomSequence_Initialize(RandSequence, linear_rand, FrameRandomSeed);
    uint2 PixelCoord = DispatchRaysIndex().xy; // Hmmmm.... does TraceRayAndAccumulateResults() assume screen-space trace or is this just for stochastics?  hopefully the latter but fixme:checkme

    FMaterialClosestHitPayload Payload = TraceRayAndAccumulateResults(
        Ray,
        TLAS,
        RefractionRayFlags,
        RefractionInstanceInclusionMask,
        RandSequence,
        PixelCoord,
        MaxNormalBias,
        ReflectedShadowsType,
        ShouldDoDirectLighting,
        ShouldDoEmissiveAndIndirectLighting,
        bRefractionRayTraceSkyLightContribution,
        bRefractionDecoupleSampleGeneration,
        RayCone,
        bRefractionEnableSkyLightContribution,
        PathVertexRadiance);

    // Adjust emissive contribution if we should
    PathVertexRadiance += Payload.Radiance * (DDGIVolume_EmissiveMultiplier - 1.0f);

    result = float4(PathVertexRadiance.xyz, Payload.HitT);

    // Ray miss. Set hit distance to a large value and exit early.
    if (Payload.IsMiss())
    {
        result.rgb += GetEnvironmentalRadiance(Ray.Direction);
        result.w = 1e27f;
        WriteRadianceOutput(DispatchIndex.xy, result);
        return;
    }

    // Hit a surface backface. Set the radiance to black and exit early.
    if (!Payload.IsFrontFace() && Payload.ShadingModelID != SHADINGMODELID_TWOSIDED_FOLIAGE)
    {
        // Shorten the hit distance on a backface hit by 80%
        // Make distance negative to encode backface for the probe position preprocess.
        WriteRadianceOutput(DispatchIndex.xy, float4(0.0f, 0.0f, 0.0f, -Payload.HitT * 0.2f));
        return;
    }

#if RTXGI_DDGI_PROBE_STATE_CLASSIFIER
    // hit a frontface, but probe is inactive, so this ray will only be used for reclassification, don't need any lighting
    if (probeState == PROBE_STATE_INACTIVE)
    {
        WriteRadianceOutput(DispatchIndex.xy, float4(0.0f, 0.0f, 0.0f, Payload.HitT));
        return;
    }
#endif

    float3 probeLighting = float3(0.0f, 0.0f, 0.0f);
    {
        float3 albedo = Payload.BaseColor - Payload.BaseColor * Payload.Metallic;

        // fill out a DDGIVolumeResources
        DDGIVolumeResources resources;
        {
            resources.probeIrradianceSRV = DDGIVolume_ProbeIrradiance;
            resources.probeDistanceSRV = DDGIVolume_ProbeDistance;
            resources.bilinearSampler = DDGIVolume_LinearClampSampler;
#if RTXGI_DDGI_PROBE_RELOCATION
            resources.probeOffsets = DDGIVolume_ProbeOffsets;
#endif
#if RTXGI_DDGI_PROBE_STATE_CLASSIFIER
            resources.probeStates = DDGIVolume_ProbeStates;
#endif
        }

        // Get irradiance from the DDGIVolume
        float3 surfacePosWS = Ray.Origin + Ray.Direction * Payload.HitT;
        float3 surfaceBias = DDGIGetSurfaceBias(Payload.WorldNormal, Ray.Direction, DDGIVolume);
        float3 irradiance = DDGIGetVolumeIrradiance(
            surfacePosWS,
            surfaceBias,
            Payload.WorldNormal,
            DDGIVolume,
            resources
        );

        // Perfectly diffuse reflectors don't exist in the real world. Limit the BRDF
        // albedo to a maximum value to account for the energy loss at each bounce.
        float maxAlbedo = 0.9f;

        probeLighting = irradiance * (min(albedo, maxAlbedo) / RTXGI_PI);
        probeLighting /= DDGIVolume_IrradianceScalar;

        // don't apply volume lighting outside the volume
        float3 relPos = abs(surfacePosWS - DDGIVolume_Origin);
        if((relPos.x > DDGIVolume_Radius.x || relPos.y > DDGIVolume_Radius.y || relPos.z > DDGIVolume_Radius.z))
            probeLighting = float3(0.0f, 0.0f, 0.0f);
    }

    WriteRadianceOutput(DispatchIndex.xy, float4(PathVertexRadiance.xyz + probeLighting, Payload.HitT));
}
